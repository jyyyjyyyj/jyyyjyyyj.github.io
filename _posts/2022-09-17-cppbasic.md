---
layout: post
title: 抱佛脚学C++
subtitle: C++ Basics
tags: [code]
---

这是为秋招准备的一篇关于C++八股文的备忘录，记录了一些面试中被问到过或者没问到过，并且本人觉得有些困难，且**个人认为不太常见或者有些难记**的问题，并且会随着秋招进程的推进而更新。大多都参考了leetocode里的两本关于C++的leetbook（下血本充了三个月会员才看的）。一些相对常见并且比较基础的问题，比如堆和栈的区别啊，vector list底层原理等等，就不作记录了。


**1. 如何用宏来实现比大小函数？**（小米面试）

这是我在面试小米的时候遇到的问题，由于这个岗位偏底层，所以面试官问的也是一些比较底层的问题，这道题我一开始答对了后来又改错了……心痛。

想要解决这个问题，首先需要明白宏实现的是简单的代码替换，并不会对正确性进行检查，因此函数里需要加入一些括号来避免歧义，同时也不需要写return之类的东西。所以应该这么写：`#define MAX(X, Y) (X) > (Y) ? (X) : (Y)`。

需要注意的是，在用宏实现函数的时候，变量外面要加上括号，因为如果`X`或者`Y`是表达式的话，可能会产生一些歧义，比如：

```c++
#define TEST(X, Y)  X - Y

int main()
{
	int x = 6, y = -1;
	int z = TEST(x+y, x-y);
	//如果宏里面没有加括号，那么等式右边替换之后变成这样了: x+y-x-y，算出来结果是0，很明显是不对的
}
```

那么如何利用宏来实现位运算呢？比如将某个四字节整数的最后四位全都设为0：

```C++
#define SET_BIT(X)  (X) = (X) & (0xFF<<4)
```

**2. 大端序和小端序**

其实就是数据在内存中的存储方式，大端序里，多位数的低位放在低地址，高位放在高地址；小端序就是反过来。英特尔笔试的一道编程题里考到了大端序和小端序的转换，虽然哪怕不知道大端序和小端序的概念也通过测试用例猜出来，我觉得还是稍微了解一下比较好。

**3. 浮点数是怎么存储的？**

在多个企业的笔试选择题里遇到了这个问题。在C++中，浮点数的存储遵循了IEEE 754标准，可以用value = sign × pow(2,exponent) × fraction的形式进行表示。其中sign就是符号位，而exponent表示指数偏移值，以float为例，这个偏移值占8位，其范围就是 -127~128。而剩下的23位表示的是fraction（尾数），就是1.xxx小数点之后二进制分数。

~~这么细节的东西都考，有病吧！~~

**4. override关键字** （华为面试）

华子的面试问到了什么是override，我当时脑子一片混沌，只是依稀记得和虚函数继承有关系，然后就回答了隐藏。。

我觉得弄清楚这三个容易混淆的概念很重要：重写（override），重载（overload）和隐藏（hide）。

其中，**重载**是针对在同一个可访问区里，于具有相同的名字，不同的参数列表（哪怕仅仅是参数顺序不一样也是不同）的函数，调用的时候会根据参数列表来选择合适的函数。重载并不关心返回值，只关心参数列表的不同。而**隐藏**是指，当派生类中有一个和基类函数同名的函数时，如果这两个函数的返回类型或者参数列表不同，那么基类的函数会被隐藏，如果相同，但是该函数并不是虚函数，那么照样会被隐藏。如果想要在派生类中调用这个基类函数，则需要显式地注明此函数来自于基类，否则会默认调用派生类中的同名函数，这样的话可能会因为参数列表的不同而报错。

而**重写**是指在派生类中重新实现基类的虚函数，这二者的返回值，名称以及参数列表都相同，只是花括号里的实现内容不一样。

如果派生类中的某个函数声明的时候使用了override，那么该函数必须要重写基类中对应的虚函数，否则会报错。override的好处在于，可以避免想要重写，但是却一不小心在什么地方写错了，导致隐藏了基类函数的情况。与override对立的关键字是**final**，将它加在基类虚函数的后面，可以禁止该函数被重写。

**5. inline的注意事项**

关于inline的用法应该是一个高频考点，我在小米和华子的面试中都被问到过inline有关的问题。inline的基本作用和好处我就不写了，在这里我想写一些（我认为）不太容易被注意到的点。

假如class是在头文件里定义的，那可以在另一个cpp文件里定义inline函数吗？  **不可以。**

inline可以去除函数只能定义一次的限制（可以在头文件里定义，然后头文件被多个其他文件include）。

虚函数不可以inline，因为虚函数是在运行期间确认的，而inline是在编译期间进行代码替换。

此外，并不是你要inline编译器就会听你的，而是会根据函数体的内容来决定是否inline。如果函数包含循环，递归，静态变量，switch或goto语句等，编译器可能不会接受inline的请求。

inline和宏相比，好处在于：inline有宏替换的效率，同时又弥补了宏无法安全检查的缺点，并且去除了函数无法在头文件里定义的限制。

 **6. 待续……**

## Reference

- [C++面试突破](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vv7bzs/)
  
- [C++面试突击](https://leetcode.cn/leetbook/detail/cpp-interview-highlights/)
 
- [C++ override 关键字用法](https://blog.csdn.net/xiaoheibaqi/article/details/51272009)