---
layout: post
title: 抱佛脚学C++
subtitle: C++ Basics
tags: [code]
private: true
---
这是为秋招准备的一篇关于C++八股文的备忘录，记录了一些面试中被问到过或者没问到过，并且本人觉得有些困难，且**不太常见或者有些难记**的问题，此外还会有很容易被问到的基础算法（比如LRU，路径规划等等），并且会随着秋招进程的推进而更新。内容大多都参考了leetocode里的两本关于C++的leetbook（下血本充了三个月会员才看的）。一些相对常见并且比较基础的问题，比如多态怎么实现啊，堆和栈的区别啊，vector list底层原理等等，就不作记录了。


**1. 如何用宏来实现比大小函数？**（小米面试）

这是我在面试小米的时候遇到的问题，由于这个岗位偏底层，所以面试官问的也是一些比较底层的问题，这道题我一开始答对了后来又改错了……心痛。

想要解决这个问题，首先需要明白宏实现的是简单的代码替换，并不会对正确性进行检查，因此函数里需要加入一些括号来避免歧义，同时也不需要写return之类的东西。所以应该这么写：`#define MAX(X, Y) (X) > (Y) ? (X) : (Y)`。

需要注意的是，在用宏实现函数的时候，变量外面要加上括号，因为如果`X`或者`Y`是表达式的话，可能会产生一些歧义，比如：

```c++
#define TEST(X, Y)  X - Y

int main()
{
	int x = 6, y = -1;
	int z = TEST(x+y, x-y);
	//如果宏里面没有加括号，那么等式右边替换之后变成这样了: x+y-x-y，算出来结果是0，很明显是不对的
}
```

那么如何利用宏来实现位运算呢？比如将某个四字节整数的最后四位全都设为0：

```C++
#define SET_BIT(X)  (X) = (X) & (0xFF<<4)
```

**2. 大端序和小端序**（英特尔笔试）

其实就是数据在内存中的存储方式，大端序里，多位数的低位放在低地址，高位放在高地址；小端序就是反过来。英特尔笔试的一道编程题里考到了大端序和小端序的转换，虽然哪怕不知道大端序和小端序的概念也通过测试用例猜出来，我觉得还是稍微了解一下比较好。

**3. 浮点数是怎么存储的？**

在多个企业的笔试选择题里遇到了这个问题。在C++中，浮点数的存储遵循了IEEE 754标准，可以用value = sign × pow(2,exponent) × fraction的形式进行表示。其中sign就是符号位，而exponent表示指数偏移值，以float为例，这个偏移值占8位，其范围就是 -127~128。而剩下的23位表示的是fraction（尾数），就是1.xxx小数点之后二进制分数。

~~这么细节的东西都考吗，望天。~~

**4. override关键字** （华为面试）

华子的面试问到了什么是override，我当时脑子一片混沌，只是依稀记得和虚函数继承有关系，然后就回答成了隐藏。。

我觉得弄清楚这三个容易混淆的概念很重要：重写（override），重载（overload）和隐藏（hide）。

其中，**重载**是针对在同一个可访问区里，具有相同的名字，不同的参数列表（哪怕仅仅是参数顺序不一样也是不同）的函数，调用的时候会根据参数列表来选择合适的函数。重载并不关心返回值，只关心参数列表的不同。而**隐藏**是指，当派生类中有一个和基类函数同名的函数时，如果这两个函数的返回类型或者参数列表不同，那么基类的函数会被隐藏，如果相同，但是该函数并不是虚函数，那么照样会被隐藏。如果想要在派生类中调用这个基类函数，则需要显式地注明此函数来自于基类，否则会默认调用派生类中的同名函数，这样的话可能会因为参数列表的不同而报错。

而**重写**是指在派生类中重新实现基类的虚函数，这二者的返回值，名称以及参数列表都相同，只是花括号里的实现内容不一样。

如果派生类中的某个函数声明的时候使用了override，那么该函数必须要重写基类中对应的虚函数，否则会报错。override的好处在于，可以避免想要重写，但是却一不小心在什么地方写错了，导致隐藏了基类函数的情况。与override对立的关键字是**final**，将它加在基类虚函数的后面，可以禁止该函数被重写。

**5. inline的注意事项**

关于inline的用法应该是一个高频考点，我在小米和华子的面试中都被问到过inline有关的问题。在这里我想写一些（我认为）不太容易被注意到的点。

假如class是在头文件里定义的，那可以在另一个cpp文件里定义inline函数吗？  **不可以。**

inline可以去除函数只能定义一次的限制（可以在头文件里定义，然后头文件被多个其他文件include）。

虚函数不可以inline，因为虚函数是在运行期间确认的，而inline是在编译期间进行代码替换。

此外，并不是你要inline编译器就会听你的，而是会根据函数体的内容来决定是否inline。如果函数包含循环，递归，静态变量，switch或goto语句等，编译器可能不会接受inline的请求。

inline和宏相比，好处在于：inline有宏替换的效率，同时又弥补了宏无法安全检查的缺点，并且去除了函数无法在头文件里定义的限制。

此外，inline也是有一些**缺陷**的，比如：inline函数太多会导致有很多代码重复，可执行文件太大；内联函数中的变量需要额外的寄存器，会在寄存器资源利用方面产生额外的开销；由于内联函数会导致可执行文件增大，可能会造成内存抖动（也就是操作系统会频繁地将页面调入调出内存）。


 **6. 如何限制对象只能创建在堆或栈上？**
 
栈一般用于存储局部变量，函数参数，返回地址等等，栈上的对象的构造和析构是由编译器完成，而堆的空间是由用户自行管理的，需要用`new`关键字来创建对象。

**限制对象创建在堆上**：那么就需要避免直接调用类的构造函数。我们可以将构造函数和析构函数设为protected（这样派生类仍然可以访问），如果构造函数是private或protected，那么编译器无法调用，就无法再栈上建立对象，如果析构函数是private或protected，编译器发现构造之后没法析构，那么也不会在栈上建立对象。

为了让对象能够建立在堆上，再重新写一个public的静态函数来完成构造，通过调用这个静态函数，可以完成对象在堆中的创建。以下是一个例子：

```c++
class A
{
protected:
    A() {}
    ~A() {}

public:
    static A *create()
    {
        return new A();
    }
    void destroy()
    {
        delete this;
    }
};
```

**限制对象创建在栈上**：那么让`new`不能用就行了，在类的内部重载operator new()，将它设为private即可（同时delete也要重载）。

**7.  如何禁止类的拷贝？**

一个很简单的想法就是把类的拷贝构造函数和赋值运算符都设为private，但是仅仅这样可不够，因为友元是可以访问这些private成员的。所以在此基础上，我们还需要声明一个派生类私有继承它，这样的话，派生类无法重写拷贝构造函数和赋值运算符，在外部也不可以调用它们。

~~真是让人头皮发麻的骚操作。~~

**8. 一些关键字**

我感觉C++里面有些关键字很难记，因为平时也不怎么用到，光看字面意思也猜不出功能。

**explicit**： 用来声明类的构造函数是显式调用的，可以避免调用构造函数的时候发生隐式转换。只用于修饰单参构造函数（因为无参和多参本身就是显式的），以下是一个例子。

```c++
#include <iostream>
#include <cstring>
using namespace std;

class A
{
public:
    int var;
    A(int tmp)
    {
        var = tmp;
    }
};
int main()
{
    A ex = 10; // 发生了隐式转换
    return 0;
}
```

如果把`A`的构造函数写成`explicit A(int tmp)`，此时`A ex = 10`就会报错了。


**define和typedef的区别**：

在前面曾经提到过，`#define`所做的是简单的文字替换，在编译预处理期间进行替换，不做类型检查，可以给常量、类型等定义别名，还可以定义编译开关等等。而`typedef`是一个关键字，在编译时处理，有类型检查功能，是给某个类型定义一个别名。

`#define`没有作用域限制，在头文件里用了`#define`，那么所有include它的cpp文件都可以使用。而`typedef`是有作用域限制的，如果在函数内部用了`typedef`，那么只能在函数内部起作用。

此外，在定义指针的时候，由于`#define`只是做了简单替换，可能会出现一些问题，比如：

```c++
#define PTR char*

int main()
{
	PTR x, y, z;
	//此时等价于char* x, y, z，只有x是char*，y和z都是char。如果用typedef就不会有这个问题。
}
```


**volatile**： volatile的作用是阻止编译器进行过度优化，从而可以提供对特殊地址的稳定访问。包括：阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回（缓存一致性协议、轻量级同步），阻止编译器调整操作 volatile 变量的指令排序。要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据，而且读取的数据立刻被保存。


**9. 待续……**




## 常考查的算法

**1. Dijkstra**

dijkstra是一种单源最短路径算法，主要思想是贪心。dijkstra将节点分为两类：已经确定了从起点开始的最短路的节点，已经未确定最短路的节点。每次从未确定节点中取出到起点距离最短的那个，并用其来更新起点到其邻居节点的距离，直到所有节点都被归类为已确定节点。需要注意的是，dijkstra不适用于权重为负数的边。

有几种方法可以实现dijkstra。由于每次更新前，需要从未确定节点中取出到起点距离最短的那个点，我们很容易可以想到用优先队列来解决问题：

```c++
//输入：edges：表明两两相连的节点，dists：edges中每条边的权重，n：节点数量，start：起始点
vector<int> dijkstra(vector<vector<int>>& edges, vector<int>& dists, int n, int start)
{
	vector<vector<pair<int,int>>> graph(n);
	
	//首先根据edges建图
	for (int i = 0; i < edges.size();i++)
	{
		graph[edges[i][0]].emplace_back(edges[i][1],dists[i]);
		graph[edges[i][1]].emplace_back(edges[i][0],dists[i]);
	}

	//小顶堆
	priority_queue<pair<int, int>,vector<pair<int,int>>,greater<pair<int,int>>> q;
	vector<int> min_dists(n, INT_MAX);
	min_dists[start] = 0;
	q.emplace(0, start);
	while (!q.empty())
	{
		//每次取出距离起始点最短的那个点
		auto p = q.top();
		int node = p.second, dist = p.first;
		q.pop();
		for (auto p : graph[node])
		{
			//距离变小了就更新
			if (min_dists[p.first] < min_dists[node] + p.second)
			{
				min_dists[p.first] = min_dists[node] + p.second;
				q.emplace(min_dists[node] + p.second, p.first);
			}
		}
	}
	return min_dists;
}
```


**2. A-star 算法**

A-star算法是游戏开发中很常用的一种算法，其对dijkstra进行了一些优化。

在dijkstra中，我们每次都从优先队列里取出距离起始点最近的那个点，并进行更新，而Astar算法中还增加了辅助判断的内容：计算该点到终点的曼哈顿距离，这样可以防止跑到一些过于偏远的地方。假设该点到起点的距离为$g(i)$，而到终点的曼哈顿距离为$h(i)$，那么最后用于估算的估价函数就是$g(i)+h(i)$。我们将估价函数连同节点存入优先队列，每次从里面取出估价函数最小的那个结点并向四周扩展，直到优先队列变空位置。

假设给定一个m×n的地图，需要从起始点走到终点，中间存在一些障碍物，则A-star算法的代码如下：


```c++
struct Node {
	int x, y; //坐标
	int G, H, F; //F = G + H
	Node* prev = nullptr; //上一个格子
	Node():x(-1),y(-1),G(INT_MAX),H(INT_MAX),F(INT_MAX),prev(nullptr){}
	Node(int a, int b, int c, int d, int e):x(a),y(b),G(c),H(d),F(e),prev(nullptr){}
	Node(int a, int b, int c, int d, int e, Node* n):x(a),y(b),G(c),H(d),F(e),prev(n){}
	
	//用于优先队列比大小
	bool operator < (const Node& n) const {
        return F > n.F;
    }
};

int print_route(Node* n)
{
	//打印路径
	int cnt = 0;
	while (n != nullptr)
	{
		cout << n->x << " " << n->y << endl;
		cnt++;
		n = n->prev;
	}
	return cnt;
}

int Astar(vector<vector<int>>& map, vector<int>& st, vector<int>& ed)
{
	//假设可走的地方值为0，障碍物为1.
	//2表示将节点加入了openlist，3表示加入closelist
	int dirs[4][2] = { 0,1,0,-1,1,0,-1,0 };
	int m = map.size();
	int n = map[0].size();
	priority_queue<Node*> q;
	int tmp = abs(ed[0] - st[0]) + abs(ed[1] - st[1]);
	Node* head = new Node(st[0], st[1], 0, tmp, 0 + tmp);
	q.push(head);

	while (!q.empty())
	{
		auto p = q.top();
		q.pop();
		int x = p->x;
		int y = p->y;
		map[x][y] = 3;
		if (x == ed[0] && y == ed[1]) //找到终点了
		{
			int r = print_route(p); //打印路径
			return r;
		}
		for (int i = 0; i < 4; i++)
		{
			int x1 = x + dirs[i][0];
			int y1 = y + dirs[i][1];
			if (x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && map[x1][y1] == 0) //可访问
			{
				int g = p->G + 1;
				int h = abs(ed[0] - x1) + abs(ed[1] - y1);

				Node* n = new Node(x1, y1, g, h, g+h, p);
				map[x1][y1] = 2;
			}
		}
	}

}
```


**3. topK问题**

topK问题是一个很高频的面试问题，需要在一串数组中查找第k大的数字。我们知道快速排序中每次迭代会将数组分割成大于$num[i]$和小于$num[i]$两部分，这样可以确定$num[i]$在排序后数组中的位置。因此，我们可以借助快速排序来找到这第k个数，这个方法被称为“快速选择”。需要注意的是，我们不需要对整个数组进行排序，只需要找到$num[i]$左右两侧中第k个数字所在的那一侧，并迭代地进行查找即可。

```c++
int select(vector<int>& nums, int st, int ed, int k)
{
	int i = st, j = ed;
	int val = nums[i];
	while (i < j)
	{
		while (i < j && nums[j] >= val)
			j--;
		if (i < j)
			nums[i++] = nums[j];
		while (i < j && nums[i] <= val)
			i++;
		if (i < j)
			nums[j--] = nums[i];
	}
	nums[i] = val;
	if (i == k)
		return nums[i];
	else if (i < k)
		return select(nums, i + 1, ed, k);
	else
		return select(nums, st, i - 1, k);
}

int topK(vector<int>& nums, int k)
{
	int n = nums.size();
	return select(nums, 0, n - 1, k);
}
```


## Reference

- [C++面试突破](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vv7bzs/)
  
- [C++面试突击](https://leetcode.cn/leetbook/detail/cpp-interview-highlights/)
 
- [C++ override 关键字用法](https://blog.csdn.net/xiaoheibaqi/article/details/51272009)
