---
layout: post
title: 查找和排序算法
subtitle: Searching and sorting algorithm
tags: [code]
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>


<style> 
  img{ 
     width: 60%; 
     padding-left: 20%; 
  } 
</style>


周一连着考了两场试，这学期的课程算是结束了，可以稍微放松一下了。

本篇博客的内容是查找和排序算法。这应该是相对基础的算法知识了，然而我总是记不住，每次看见排序的题目就头大，于是打算趁着春节前的这几天再重新总结一遍。

### 目录
		* [1. 冒泡排序](#1-冒泡排序)
		* [2. 插入排序](#2-插入排序)
		* [3. 归并排序](#3-归并排序)
			* [一个更复杂的例子：数组中的逆序对](#一个更复杂的例子数组中的逆序对)


以下算法排序时默认采用升序：

### 1. 冒泡排序

冒泡排序是一种比较简单的排序算法（大一的C++课上讲过），它的过程是：

1. 从头到尾遍历数组里的每个元素，如果发现两个相邻元素的大小关系不符合要求，就交换这两个元素的位置。当一次遍历完成之后，在数组末尾的元素应该是被遍历元素中最大/最小的元素（取决于是升序还是降序排列），它的位置就固定住了。
   
2. 重复步骤1，在上一次遍历的最后一个元素前停止，直到所有元素都排序完成。

假设数组里有$n$个元素，冒泡排序每次都确定至少一个元素的位置，那么需要遍历数组$n-1$次，其中第$i$次遍历的元素数量为$n-i$($i$从0开始计数），算法时间复杂度是$O(n^2)$，空间复杂度是$O(1)$。冒泡排序是**稳定**的。所谓稳定性就是指，假设在原数组中有两个元素$a = b$，且排序后$a$和$b$的相对次序没有变，则该算法是稳定的，否则是不稳定的。

代码如下：

```c++
//升序
void bubble_sort(vector<int>& arr)
{
	int n = arr.size();
	for (int i = 0; i < n - 1; i++) //遍历的次数
	{
		for (int j = 0; j < n - 1 - i; j++) //每次遍历的元素
		{
			if (arr[j] > arr[j + 1])
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
	}
	return;
}
```


### 2. 插入排序

同时也是一种比较简单的排序算法。插入排序（升序）的过程如下：

1. 取出数组中的第$i$个元素（从0开始计数，$i$的初始值为1），并将它与之前的元素进行比较。如果找到了一个小于它的元素$a$（降序排列的话就是大于），就将第$i$个元素插入到$a$的后面，如果没有找到，就将第$i$个元素放在最前面。
   
2. $i=i+1$，重复步骤1，直到遍历完数组最后一个元素。

如果通过在原地修改数组来实现排序的话，每次插入的时候需要将部分元素向后移1位。插入排序的时间复杂度为$O(n^2)$，空间复杂度是$O(1)$，是稳定的排序算法。

代码如下：

```c++
//升序
void insertion_sort(vector<int>& arr)
{
	int n = arr.size();
	for (int i = 1; i < n; i++) //每次插入的元素
	{
		int tmp = arr[i];
		int j = i - 1;
		while (j >= 0 && arr[j] > tmp)
		{
			arr[j + 1] = arr[j]; //后移一位
			j--;
		}
		arr[j + 1] = tmp;
	}

	return;
}
```

当数组元素数量比较多的时候，以上两个$O(n^2)$的算法就显得有些麻烦了。


### 3. 归并排序

归并排序采用了分治（divide and conquer）的思想，它递归地地将数组一分为二，对分裂出的子数组进行排序，最后将排序好的子数组合并在一起，我画了一张简单的图来解释这个过程：

![enter description here](../assets/2022-01-25/mergesort.png)

在合并子数组的时候，首先让两个指针分别指向子数组的第一个元素，将较小的元素存入合并后的数组中，并将其对应的指针后移一位。最后不断的重复这个操作直到某个指针率先事先到达数组末位，再将另一个数组中没有被遍历到的元素挨个存进去即可。

归并排序的时间复杂度是$O(n\log n)$，空间复杂度是$O(n)$，是一种稳定的算法。它需要开辟额外的空间来存放分裂后的子数组。

代码如下：

```c++
void merge_sort(vector<int>& arr)
{
	int n = arr.size();
	if (n > 2)
	{
		vector<int> left(n / 2);
		vector<int> right(n - n / 2);
		int i = 0;
		//如果数组长度大于2，将数组一分为二
		for (; i < n / 2; i++)
			left[i] = arr[i];
		for (; i < n; i++)
			right[i - n / 2] = arr[i];
		merge_sort(left);
		merge_sort(right);
		arr = merge(left, right);//合并两个数组
	}
	else if(n == 2 && arr[0] > arr[1])
	{
		swap(arr[0], arr[1]);
	}
	return;
}


//合并两个已排序的数组
vector<int> merge(vector<int> left, vector<int> right)
{
	int m = left.size();
	int n = right.size();
	vector<int> rtn(m + n);
	int i1 = 0, i2 = 0, i3 = 0;
	while (i1 < m&&i2 < m)
	{
		if (left[i1] <= right[i2])
		{
			rtn[i3] = left[i1];
			i1++;
		}
		else
		{
			rtn[i3] = right[i2];
			i2++;
		}
		i3++;
	}
	while (i1 < m)
	{
		rtn[i3] = left[i1];
		i1++;
		i3++;
	}
	while (i2 < n)
	{
		rtn[i3] = right[i2];
		i2++;
		i3++;
	}
	return rtn;
}
```

#### 一个更复杂的例子：数组中的逆序对
这道题来自于剑指offer，可以借助归并排序解决，但是很难想到可以用归并排序（反正我想不出来）：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

那么怎么解这道题呢？假设输入是上面图中的数组，我们首先对其进行归并排序，在合并的过程中，有两个待合并的数组$l = [2,4,5,7]$以及$r=[1,3,6,8]$。这两个数组已经被排序好了，且一个代表了原数组的前半部分，另一个代表了后半部分。可以看出，$l[1]$比$r[0],r[1]$大，比$r[2]$及其之后的元素要小，因此$l[1]$和$r$中的元素能够组成2个逆序对。由此类推，$l[2]$和$r$中元素能够组成2个逆序对，$l[3]$可以组成3个。

在归并排序的代码中，我们采用了以下的方法来比较并拼接两个已排序的数组中的元素：

```c++
while (i1 < m&&i2 < m)
{
		if (left[i1] <= right[i2])
		{
			rtn[i3] = left[i1];
			i1++;
		}
		else
		{
			rtn[i3] = right[i2];
			i2++;
		}
		i3++;
}
```

其中，$i_1$和$i_2$代表的是$l,r$两个数组指针所处的位置。当$l[i_1] \leq r[i_2]$的时候，对于$l[i_1]$，$r[i_2]$之前的元素都比它小，因此$l[i_1]$有$i_2$个逆序对。这样一来，我们只需要对归并排序的算法稍作修改就可以计算出逆序对的数量。

代码：

```c++
class Solution {
public:
    int num; //逆序对的数量
    void merge_sort(vector<int>& arr)
    {
        int n = arr.size();
        if (n > 2)
        {
            vector<int> left(n / 2);
            vector<int> right(n - n / 2);
            int i = 0;
            //如果数组长度大于2，将数组一分为二
            for (; i < n / 2; i++)
                left[i] = arr[i];
            for (; i < n; i++)
                right[i - n / 2] = arr[i];
            merge_sort(left);
            merge_sort(right);
            arr = merge(left, right);//合并两个数组
        }
        else if(n == 2 && arr[0] > arr[1])
        {
            //有一个逆序对
            swap(arr[0], arr[1]);
            num++;
        }
        return;
    }

    vector<int> merge(vector<int> left, vector<int> right)
    {
        int m = left.size();
        int n = right.size();
        vector<int> rtn(m + n);
        int i1 = 0, i2 = 0, i3 = 0;
        while (i1 < m && i2 < n)
        {
            if (left[i1] <= right[i2])
            {
                rtn[i3] = left[i1];
                i1++;
                //有i2个逆序对
                num += i2;
            }
            else
            {
                rtn[i3] = right[i2];
                i2++;
                
            }
            i3++;
        }
        while (i1 < m)
        {
            //此时i1对应的元素比right中所有元素都大
            rtn[i3] = left[i1];
            i1++;
            i3++;
            num += n;
        }
        while (i2 < n)
        {
            rtn[i3] = right[i2];
            i2++;
            i3++;
        }
        return rtn;
    }


    int reversePairs(vector<int>& nums) {
        num = 0;
        int n = nums.size();
        merge_sort(nums);
        //for(int i = 0; i < n;i++)
        //    cout<<nums[i]<<endl;
        return num;
    }
};
```
（写完之后运行了一下，发现占用的内存空间太大了，归并函数的merge()按理说不需要额外开辟空间，只有在分割的时候需要开辟额外的空间。我的写法实在是太二了。。。后续我会改正这一部分）

先到这里，接下来内容以后再补充
