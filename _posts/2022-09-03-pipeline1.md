---
layout: post
title: 图形渲染管线 I
subtitle: Rendering Pipeline I
tags: [graphics]
---


好久都没有写博客了，因为秋招的事情搞得我焦头烂额。最近三天有两场面试五场笔试（啊！毁灭吧！），忙得我是晕头转向。

说到找工作，我一直很向往游戏行业，也给各大游戏公司都投了简历（截至2022.09.03，已经挂掉两个了）。虽然研究生的方向和图形学也有点关联，但是和渲染，物理动画之类的领域并不太沾边，因此我投的大多都是要求相对较低的游戏客户端开发岗。

我想要在面试之前恶补一下图形学知识，然而感觉自己太焦虑了，怎么都学不进去，后来就想到了一个办法……那就是写博客呀！于是本篇博客的内容就是关于图形渲染管线的。

我主要参考了[b站上的视频](https://www.bilibili.com/video/BV1L54y1s7xw?p=2&share_source=copy_web)，虽然只有半小时但是讲得非常详细，此外还有一些技术博客。每个作者讲的内容都有一些细微的差别，不过整体上是一致的。


## 1. 图形渲染管线的基本步骤

渲染管线所做的事情，就是对一系列三维图形进行处理和变换，将其转化为一副二维图像呈现在屏幕上。在渲染管线的每一步中，下一个步骤的输入就是上一个步骤的输出，这也是其被称为“管线”的原因。对于渲染管线每个步骤的区分有很多种不同的方法，以下是其中一种常用的区分：



<div align=center>
    <img src="../assets/2022-09-03/pipeline1.png"/>
</div>

总共有四个步骤：

应用阶段，几何处理阶段，光栅化阶段和像素处理阶段。其中应用阶段是在CPU上进行的，其他的阶段在GPU进行。GPU的并行性比较好，可以用来处理批量的顶点数据。



## 2. 应用阶段

应用阶段是在CPU里实现的，能够由用户完全控制。应用阶段会对输入的图形进行一些预处理，其中的内容有：

**基本场景数据的准备**：包括场景中待渲染的物体，摄像机的数据，光源的数据，以及其他的一些全局性的数据。

更详细地说，基本场景数据包括以下这些内容：

**场景物体数据**：物体变换数据（位置，旋转，缩放等）和物体网格数据（顶点位置，uv贴图等）

**光源信息**：光源类型（方向光，点光，聚光等），位置，方向，角度等。

方向光的信息包括颜色和方向，点光源的信息包括颜色，位置和范围，聚光源包括颜色，位置，方向内外圆锥角等。此外还有关于阴影的设置，比如是否需要设置阴影，该光源可见范围内是否有可投射阴影的物体，以及阴影的参数（阴影强度，级联参数，深度偏移等）。接下来就是逐光源绘制阴影贴图（有很多种算法）。


**摄像机参数**：位置，方向，远近截面，正交/透视，视口长宽比，fov等


**空间加速，粗粒度剔除**：

视锥剔除：删除不在视锥范围内的物体。如果聚光锥和视锥不相交，也可以将其剔除。

层级剔除：以unity为例，可以通过给物体设定不同层级，让摄像机不去渲染某一层。

常用的加速方法包括一些数据结构以及算法。其中有：

层次包围盒（BVH）：用一个体积略大但是形状简单的包围盒来描述复杂的几何体，通过构造层次树状结构，可以使包围盒越来越接近被描述对象。层次包围盒经常被用在视锥体剔除中。

二叉空间分割树（BSP树）：BSP树的每个节点表示一个超平面，将当前空间分为前向和后向两个部分，即左右子节点。有了BSP树，就可以根据观察者的位置，快速地按照从前到后的顺序对场景中的对象进行访问。

还有kd树，八叉树等等树形结构可用来存储几何体。


**设置渲染状态和参数**：其中包括渲染顺序的设置，比如由近到远渲染，或者先渲染不透明的，再渲染半透明的等等，不透明的物体是从前往后排序，这样可以剔除一些被遮挡的物体，而半透明的物体需要从后往前排序。顺序通过**渲染队列**来决定。此外，不同的物体可能需要不同的着色器来渲染，渲染的结果输出也可能不同，渲染模式（比如前向渲染，延迟渲染）也需要进行设置。

**调用DrawCall**：设置完以上部分之后，处理好的场景数据包括：顶点数据（位置，颜色，法线，纹理uv坐标等），MVP变换矩阵，纹理贴图等。我们需要调用DrawCall将带有渲染数据的图元（可以是点，直线，三角形等等）输出给GPU。


## 3. 几何处理阶段

这一步以及后面的步骤就都是在GPU上实现的了。几何处理阶段主要包括：顶点着色，投影，裁剪，屏幕映射。其中顶点着色和投影之间还存在一些可选项。

**顶点着色**: 这一个步骤是可以编程的。每一个顶点都会调用一次顶点着色器，主要有坐标变换和着色（比如计算光照）两个部分。

顶点的坐标在最初始的时候是其相对于物体轴心的坐标，那么坐标变换的第一步就是根据物体相对于世界坐标系的位移/旋转/缩放，来获取顶点在世界坐标系中的位置。第二步是将顶点从世界坐标系变换到观察坐标系。第三步进行投影变换，获取其在裁剪坐标系的位置，裁剪掉一些不在投影范围内的图元。投影分为正交投影和透视投影，其中透视投影遵循近大远小的规则。这三个步骤所用到的矩阵就是MVP（model，view，projection）矩阵。

**曲面细分**：这是一个可选的步骤，就是一个三角网格细分的过程。网格细分有很多算法，这里就不提了。

**几何着色器**：也是一个可选步骤。顶点着色器的输入是顶点，而几何着色器的输入是图元（点，线段，三角形，折线段等），可以通过给定的图元生成新的图元，比如把输入的点或线段扩展成多边形。

**投影**：对于在裁剪空间中的物体，对他进行透视除法（xyz除以w），从投影坐标系转换到标准设备坐标系（NDC）。有正交投影和透视投影两种，正交投影的w为1，而透视投影遵循近大远小规则，w在近处较小，远处较大。

**裁剪**：如果经过透视除法之后的xyz坐标超出了-1~1的范围，就需要被裁减掉。如果一个图元部分处于范围之外，则需要在裁剪之后补全新的顶点。

**屏幕映射**：使用视口变换，把标准坐标系映射到屏幕上（标准坐标系的范围都是-1~1）。对于opengl来说，它的屏幕坐标原点在左下角。


这一篇博客就先写到这里，下一篇继续讨论后续的两个阶段：光栅化和像素处理阶段。

## Reference

- [实时渲染学习（十）渲染加速算法总结](https://blog.csdn.net/ljytower/article/details/89483055)

- [渲染基础](https://www.cnblogs.com/forever-Ys/p/15520028.html)

- [【技术美术百人计划】图形 1.1 渲染流水线
](https://www.bilibili.com/video/BV1L54y1s7xw?p=2&share_source=copy_web)

- [【游戏开发面经汇总】- 图形学基础篇](https://zhuanlan.zhihu.com/p/430541328)
